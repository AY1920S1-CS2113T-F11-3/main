= Email Manager - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: ..\images
:stylesDir: stylesheets
:xrefstyle: full
:repoURL: https://github.com/AY1920S1-CS2113T-F11-3/main/tree/doc

By: `Team AY1920S1-CS2113T-F11-3`      Since: `Nov 2019`
Licence: `MIT`

== Introduction

Welcome to the *Email Manager* Developer Guide!

.Main window of Email Manager
image::Ui.png[UI, 800]

*Email Manager* is an email and task manager app, specifically designed for NUS School of Computing Students to manage their emails and busy schedules.
As a text-based application, it is optimized for those who prefer typing and working with Command Line Interface (CLI).
Email Manager also has a developed Graphical User Interface (GUI) that allows users to view email and task details in an appealing, well-organized format.

== About the Developer Guide

This developer guide provides detailed documentation on the implementation of all the various features Email Manager offers.
It also suggests methods for you to modify and build upon it. +
Throughout this developer guide, there will be various icons used, as shown below:

|===
|üí°|This is a tip. Follow these tips to aid your development of Email Manager.

|===

|===
|‚ÑπÔ∏è|This is a note. Read these for additional information.

|===

|===
|‚ö†Ô∏è|This is a warning. Heed these warnings to avoid making mistakes that will hamper your development efforts.

|===

== Setting up

This section shows how to set up Email Manager on your desktop and begin your development journey.

== Design

=== Architecture

==== Overall Architecture

[#overall-architecture]
.Overall Architecture
image::OverallArchitecture.png[Overall Architecture, 400]

The overall architecture design is as shown in Figure 1. Upon the start of the program, `Storage` loads local
files
to update `Model`.

The user interact with the `UI`, which passes on the user input to `Logic` for parsing. Parsed command will be
executed to modify `Model`. Once `Model` is modified, it updates the `UI` display and calls the `Storage` to
update the local files.

==== UI component

[#ui-component]
.UI Component
image::UIComponent.png[UI Component, 400]

The `UI` class is the "gateway" of all the ui components. `Model` must go through the ui component
to update the display and the user input will be passed to the `Logic` for parsing.

`TaskCard` and `DialogBox` are generated and displayed on the main window during run time. `KeyBinding` and
`UserInputHandler` are helper class to handle the input and hotkeys.

==== Logic component

[#logic-component]
.Logic Component
image::LogicComponent.png[Logic Component, 800]

`Logic` component mainly takes in user input from `UI` and generates command to execute. All inputs first
go into `CommandParseHelper` which check for input format and do preliminary information extraction. It
generates common commands if possible.

If the input is not about a common command, the `CommandParseHelper` will call `EmailCommandParseHelper` or
`TaskCommandParseHelper` to parse the input depending on the input prefix. Email command or Task command
will be generated by these two parsers respectively.

All common, email and task commands inherit from abstract class `Command`. The reason why we do not create
`EmailCommand` and `TaskCommand` is because there is no major difference between commands for the task and
for the email. Then the `Command` is executed which modifies the `Model`.

==== Model component

[#model-component]
.Model Component
image::ModelComponent.png[Model Component, 600]

The `Model` contains a `TaskList`, a `EmailList` and a `EmailKeywordPairList`. They store `Task`, `Email`
and `KeywordPair` respectively. The three lists all inherit from `ArrayList`.

=== Overall Activity Flow

[#activity-dagram]
.Activity Diagram
image::OverallActivityDiagram.png[Overall Activity Flow, 400]

When the program first start, it initializes the model. It then loads the local data files and fetch emails
from the Outlook Server at the same time. Once these two activities are finished, it starts to wait for
user input.

If the input is received, it is parsed to command. Command will be executed depending on its type. If it is
an exit command, however, it will shutdown the program gracefully. Otherwise it updates model, which in
turn updates UI and local storage, after which the program will continue to wait for user input.

This process continues until an exit command is received.

== Implementation

This section describes some noteworthy details on how certain features in *Email Manager* are implemented.
// Maybe in the future we split the sub-sections into overall command structure, email management, task management and GUI?

=== Task Management

There are three main types of tasks that Duke Email Manager works with: `todo`, `deadline` and `event`.

==== Natural Dates Support

Natural dates support helps to speed up the process at which users enter their task details so that their
task can be added into the task list quickly. The benefits of having this Natural Dates support are:

* Reduce the time and effort needed to key in the date and time for deadline and event tasks.

|===
|‚ÑπÔ∏è|This feature only works with `deadline` and `event` tasks.

|===

===== Implementation

The following sequence diagram below illustrates how this feature works:

.Natural Dates Support Sequence diagram
image::TaskParseNaturalDate (1) (2).png[Natural Dates Support, 800]

As seen from the diagram above, the Natural Dates support is facilitated by three classes, namely
`TaskCommandParseHelper`, `CommandParseHelper` and `TaskParseNaturalDateHelper`.

`TaskParseNaturalDateHelper` is under the Command component.
It implements the following operations:

* `TaskParseNaturalDateHelper#isCorrectNaturalDate(day)` - Checks if `day` is a day of the week
* `TaskParseNaturalDateHelper#convertNaturalDate(day, time)` - Converts string day and time to local date and time in LocalTimeDate format
* `TaskParseNaturalDateHelper#getDate(timeString)` - Returns a dateTime in LocalDateTime format
* `TaskParseNaturalDateHelper#parseDate(timeString)` - Converts timeString to LocalDateTime format if
timeString is of `dd/MM/yyyy HHmm` format

`TaskCommandParseHelper` and `CommandParseHelper` are under the Parser component.
It implements the following operations:

* `TaskCommandParseHelper#parseTaskTime(optionList)` - Parses time string extracted from optionList and returns a dateTime in LocalDateTime format
* `TaskCommandParseHelper#checkTimeString(timeString)` - Checks if time string contains time component and returns a pair with day as key and timing as value
* `CommandParseHelper#extractTime(optionList)` - Extracts and returns the time string from the input

Given below is an example usage scenario and how Natural Dates Support behaves at each step.

*Step 1*: The user launches the application. The input type is currently in `email` mode.
The user wishes to add a task and keys in `flip` to switch input type to `task` mode.

*Step 2*: The user executes `deadline homework -time Mon 1200` to add a new deadline task. `UI` component captures the input and passes to `Logic` component to parse the input.

* `CommandParseHelper` takes in the `input`, parses and extracts the options and stores it inside ArrayList<Option>  `optionList`, then passes the `input` and `optionList` to `TaskCommandParseHelper`.

*Step 3*: `TaskCommandParseHelper` takes in the command, parses and extracts the time string of the task by calling `CommandParseHelper#extractTime(optionList)`.

*Step 4*: The extracted time string will go through `TaskParseNaturalDateHelper#getDate(timeString)`, which calls `TaskCommandParseHelper#checkTimeString(timeString)` and retrieves dateTimeString = new Pair<>(day, time).

*Step 5*: If `TaskParseNaturalDateHelper#isCorrectNaturalDate(day)` is true,
`TaskParseNaturalDateHelper#convertNaturalDate(day, time)` is called, else
`TaskParseNaturalDateHelper#parseDate(timeString)` is called.

*Step 6*: `TaskCommandParseHelper#parseTaskTime(optionList)` retrieve dateTime from
`TaskParseNaturalDateHelper` and returns it.

* The next nearest date is returned according to the input day
** E.g. When the timeString inputted is `sun 1200`, the date of the next nearest Sunday is returned.

===== Design Considerations

Aspect: Handling of parsed time string

* Alternative 1 (chosen): `TaskCommandParseHelper#checkTimeString(timeString)` parses and returns the time
string as a string pair that stores day as key and time as value.
** Pros: Easier to use the day and time in the pair in other methods without having to extract it from time
string again.
** Cons: Does not check whether day and time in the pair is valid, the pair can be any string.
`TaskCommandParseHelper#checkTimeString(timeString)` is called from another class which increase dependency.

* Alternative 2: Parse the time string and extract day or time before each use in `TaskParseNaturalDateHelper`
** Pros: Able to validate if time string is valid before it is called by other methods. Easier to write tests.
** Cons: Might have duplicated codes.

==== Sorting of Task List

The task list can be sorted according to what the user prefer.
The benefits of having this sorting feature are:

* Easier viewing of task list when the list is sorted.
* Faster checking of task list when the list is sorted.

|===
|‚ÑπÔ∏è|Task list can be sorted by `priority`, `status` and `time` only.

|===

===== Implementation

The following sequence diagram below illustrates how the sort command is parsed:

.parseSortCommand Sequence diagram
image::parseSortCommand (1) (1).png[Parse Sort Command, 800]

As seen from the diagram above, the parsing of sort command is facilitated by two class, namely
`TaskCommandParseHelper` and `TaskSortCommand`.

`TaskCommandParseHelper` is under the Parser component.
It implements the following operations:

* `TaskCommandParseHelper#parseSortCommand(input)` - Parse the input and extracts the sort type(sortBy) after the command `sort`
** E.g. `sort priority` -> sortBy = "priority"

`TaskSortCommand` is under the Command component.
It implements the following operations:

* `TaskSortCommand#getSortType(sortBy)` - Checks sortBy and returns the sort type if sortBy is valid

Given below is an example usage scenario and how `parseSortCommand` behaves at each step.

*Step 1*: The user launches the application.
The input type is currently in `email` mode.
The user wishes to check the task list and key in `flip` to switch input type to `task` mode.

*Step 2*: The user executes `sort priority` to sort the task list according to its priority. `UI` component captures the input and passes to `Logic` component to parse the input.

*Step 3*:  `TaskCommandParseHelper#parseSortCommand(input)` is called and extracts the sort type called
sortBy.

*Step 4*:  `TaskSortCommand#getSortType(sortBy)` is then called and returns the sort type according to sortBy

* E.g. If sortBy = "priority", sortType.PRIORITY will be returned.

*Step 5*: `TaskCommandParseHelper` returns new `TaskSortCommand(sortType)`

The following sequence diagram below illustrates how the sort command works:

.TaskSortCommand Sequence diagram
image::TaskSortCommand.png[Task Sort Command, 800]

As seen from the diagram above, the sort command is facilitated by four class, namely `TaskSortCommand`,
`Model`, `TaskList` and `UI`.

The following operations are implemented:

* `TaskSortCommand#execute(model)` - executes the sort command
* `Model#getTaskList()` - returns current task list
* `TaskList#setSortType(sortType)` - sets the sort type of the task list to `sortType`
* `TaskList#constructSortMessage(sortType)` - returns responseMsg
* `UI#showResponse(responseMSg)` - display responseMsg

Given below is an example usage scenario and how `TaskSortCommand` behaves at each step.

*Step 1*: The user executes `sort status` to sort the task list according to whether it is completed or not.

*Step 2*: `Model#getTaskList()` is called and the current taskList is returned.

*Step 3*: `TaskList#setSortType(sortType)` is called and returns a response message after calling
`TaskList#constructSortMessage(sortType)`.

*Step 4*: The UI displays the response message and `TaskSortCommand#execute(model)` returns true if the
sort type in `TaskList` is set correctly.

The following activity diagram shows the method `sortByType()` that changes how the task list is sorted
according to the sort type:

.sortByType activity diagram
image::sortByType.png[Sort By Type, 800]

|===
|‚ÑπÔ∏è|The task list is sorted according to time by default.

|===

Given below is an example usage scenario and how `TaskSortCommand` behaves at each step.

*Step 1*: The user wishes sort the task list according to the priority level of the tasks and executes
`sort priority`.

*Step 2*: The sort type is changed to `PRIORITY` from `TIME`, and the sorting method is changed.

*Step 3*: `sortByType() is called by `Model#updateGuiTaskList()` on every user input to keep task list sorted.

|===
|‚ÑπÔ∏è|
|sorted by `priority`|tasks with higher priority will be at the top of the task list.
|sorted by `status`|tasks that are not completed will be at the top of the task list.
|sorted by `time`|deadline or event tasks with nearing date and time will be at the top of the task list.
|===

===== Design Considerations

Aspect: When the sorting of task list occurs

* Alternative 1 (chosen): The task list is sorted whenever the GUI is updated.
** Pros: Ensures that the task list will always be sorted according to how the user wants.
** Cons: Sort command is executed on every user input to keep task list sorted and task list view in GUI
updated, which increases the computational load.

* Alternative 2: The task list is sorted in `TaskList` class before it is displayed by the GUI
** Pros: Sort command is called only when needed.
** Cons: Have to consider other commands (e.g. `update`) that will change the task list and requires the
task list to be sorted.

==== Updating of Tasks

Tasks have a variety of attributes that a user may want to add or change.
This may be due to the user entering wrong information or differing needs as time passes.
Thus this command affords the user some flexibility in the way he can edit tasks.
The current attributes that can be modified are: `time`, `doafter`, `priority` and `tags`.
It is easy for you to add functionality for future attributes when the need arises.
The updating of task details is facilitated by `TaskUpdateCommand`. It extends `Command`, overriding the `execute` method.

The details of the update mechanism are as follows:

Step 1: `CommandParseHelper` takes in the command from the user input text field, and parses it into the main command and the options.
The options are stored in an ArrayList, which holds them as pairs.
For example, if the input consists of `-tag school`, then `tag` will be the key and `school` will be the value for one pair in the options list.
If the command starts with `task` then it call `TaskCommandParseHelper`, passing in parsed command.

Step 2:
`TaskCommandParseHelper` does another round of parsing with the input. If the input starts with `update`, the method
`parseUpdateCommand` will be called. This method will call the `extractTime`, `extractDoAfter`, `extractPriority` and
`extractTags` methods to transfer the time, doAfter, priority and tags respectively out of the options List and into
another data structure. This so that the information will be formatted for the `TaskUpdateCommand`.

|===
|‚ÑπÔ∏è| The `extract` methods called will only extract the parameters they are designed to look for. All other keys
will be ignored (this currently includes options with a msg, email key). You can add to the functionality of this command
by creating your own `extract` method to sieve out the corresponding key.

|===

Step 3: `TaskUpdateCommand.execute()` will then go through the ArrayList, calling the appropriate
method in `TaskList`.

Step 4: The method in `TaskList` will retrieve the specified task and call the related setter to change the value.
This process repeats for all the parameters that were passed in to `TaskUpdateCommand`.

==== Linking emails to task
As Email Manager handles both emails and tasks, this command allows the connection of functionalities between the two modes.
Users are able to add emails into a list within a task object.

This command is able to take in two types of parameters: `email` and `delete`.
`email` adds the specified email to the list, while `delete` removes the specified index from the list.
If no `email` or `delete` parameters are included in the command, the list of linked emails for that task will be displayed.

This command is enabled through TaskLinkCommand.

The mechanism works as follows:

Step 1: Like the other commands, the input will be parsed and the parameters stored in the options list.
The parse link command will extract out the email and delete parameters by calling the extractEmails and extractDelete methods respectively.
The returned arraylists are then passed to the TaskLinkCommand.

Step 2: TaskLinkCommand sets up.

Step 3: First, TaskLinkCommand will check if there are any email links to be deleted.
This has to be done first (before the addition of email links) as the list may be altered.
If there are email links to be deleted, the corresponding index will be removed from the list.

Step 4: The emails will be added. This function calls email list to convert the index into the SHA hash of the email.
This required as emails may be added and/or deleted, changing the indexes of all the emails.
The returned SHA hash is then stored in the linkedEmails array list of the task.

Step 5: The current list of emails are now displayed.
First it calls the convert SHA to subject to convert the SHA hash into a user readable subject line.
This is printed in a list format and the first email of the list is shown in the email pane.

Step 6: The response message is displayed by the UI to feedback to the user what actions have been performed as well as the latest version of the list.


=== Email Management

==== Email Auto Parsing

The emails fetched or stored locally will be automatically parsed to extract important information for tagging, task creation and reminder purposes.
The parsing consists of two stages, the *format parsing* and *content parsing*.
Email format parsing is to parse the email components like subject, sender and body from the raw string fetched from the server or stored in local file.
The content parsing is to parse the keyword included all components of email.

===== Email Format Parsing

.Email Format Parsing
image::EmailFormatParseHelper.png[Format Parsing, 800]

The email format parsing starts at the call of `ParseFetchResponse(response)`. The variable `response` here
is a string of the http response from the Outlook server to the fetch API call.


It first creates an `EmailList` to store all the emails parsed from the response.
This function only returns the list instead of directly adding the email parsed to the model because the storage or network component will decide whether and how the emails are to added to the model.

Then each email contained in the response of is parsed to a `JSONObject` called `emailJson` for easier manipulation.

With this `emailJson`, `parseComponentsToEmail(emailJson)` is called to extract different components of the json and instantiate an `Email` object to be added to the `emailList` created earlier.

This process repeats until all the email information in the response is processed.

===== Email Content Parsing

.Email Content Parsing
image::EmailContentParseHelper.png[Content Parsing, 800]


Email content parsing is to parse the keyword from different components of an email.

Email content parsing starts with the calling of `allKeywordInEmail(email)` and parse in the email in
`Email` type.

It then gets all the `KeywordPair` from the `KeywordList`.
A `KeywordPair` contains a human readable
`keyword` signifying the "meaning" of the keyword.
It also contains multiple `expressions` which will be looked through the email for matches.

For each email component (subject, sender, body etc), the `keywordInString(emailComponent, keywordPair)` is called to search for matches across these components.
It will then return a relevance score.
Higher relevance score means a more occurrence.
Keyword with all its expressions absent in the email will get a 0 relevance score.
Also, subject and sender will have a higher weights compared to the email body.

Each keyword searched in the email with a relevance score higher than 0 (at least 1 occurrence), will be added to the email as a tag by calling `addTag(keywordPair, relevanceScore)`.

==== Email Tagging

*Email Manager* allows user to tag emails by tags.

===== Current Implementation

* Format:¬†`email update ITEM_NUMBER [-tag TAG1] [-tag TAG2]`‚Äã
Following is the activity diagram when the command is executed:

.Activity diagram for email tagging
image::emailTagActivityDiagram.jpg[Email Tag Activity Diagram, 800]

The following sequence diagram below will explain how the¬†`email update`¬†command works in detail:

.Sequence diagram for email tagging
image::emailTagSequenceDiagram.jpg[Email Tag Sequence Diagram, 800]

An example usage of the command is as follows:

*Step 1*: The user launches the application.
The user inputs `email update 2 -tag Fun -tag Project`

*Step 2*: `UI` component captures the input and passes to `Logic` component to parse the input.
Section below explains how `Logic` component parse the input.

* `CommandParseHelper` takes in the `input`, parses and extracts tags information and stores it inside ArrayList<Option>  `optionList`, then passes the `input` and `optionList` to `EmailCommandParseHelper`.
** `input` here is `email update 2`
** `optionList` here is `[tag=Fun, tag=Project]`
* `EmailCommandParseHelper` parses the `index` of email and extract tags information `optionList` and stores it in ArrayList<String> `tags`.
** `index` here is `2`
** `tags` here is `[Fun, Project]`
* `EmailCommandParseHelper` creates a new `EmailTagCommand` by passing in `index` and `tags`, then return the `EmailTagCommand` to `CommandParseHelper` and then to `UI`

*Step 3* : `EmailTagCommand#execute(model)` is called by `UI`.

*Step 4*: `EmailTagCommand` calls `Model#getEmailList()`, then `emailList` is returned by `Model`.

*Step 5*: `EmailTagCommand` calls `EmailList#addTags(index, tags)`

* `EmailList` calls `get(index)` to get the email of the index number in the emailList.
** Gets the 2nd email in the emailList.
* For each `tag` in `tags`, `EmailList` calls `Email#addTag(tag)`. `Email` calls `tags.add()` to add the tag to the email.
** Each `tag` here is `Fun` and `Project`.

*Step 6*: `EmailList` returns a String `responseMsg` to `EmailTagCommand`.

** `responseMsg` here is: +
 "Tags added: [Project, Fun] to email: <title of email at index 2>"

===== Design Considerations

Aspect: Handling updating of tags

* Alternative 1 (current choice): if at least one tag is entered as part of the command, it will overwrite all current tags of the task being modified.
** Pros: makes it consistent with other parameters of the update command and gives users an option to replace/remove tags
** Cons: if there are many tags, and the user only wants to add on an extra tag, the user will need to retype all existing tags into the command.
* Alternative 2: if a tag is entered as part of the command, it will amend on top of existing tags.
** Pros: this will save users time if they only want to add on tags
** Cons: no option to remove tags
* Alternative 3 (proposed): there will be an option to add tags and an option to remove tags.
** Pros: gives users highest amount of flexibility and control over the tags they want to keep.
** Cons: added complexity in commands

==== Email Filtering by Tag(s)

*Email Manager* allows user to filter emails by tag(s).

===== Current Implementation

* Format: `list [-tag TAG1] [-tag TAG2]‚Ä¶`

* Note: Gives a list of emails with the tags.
Minimum number of tags is 1, and the maximum is 2.
* Eg: `email list -tag Fun -tag Project`

Following is the activity diagram when the command is executed:

.Activity diagram for email filtering by tags
image::emailFilterActivityDiagram.jpg[Email Filtering Activity Diagram, 800]

The following sequence diagram below will explain how the `email update` command works in detail:

.Sequence diagram for email filtering by tags
image::emailFilterSequenceDiagram.jpg[Email Filter Sequence Diagram, 800]


An example usage of the command is as follows:

*Step 1* : The user launches the application.
The user wishes to tag the 2nd email in the list with "Fun" and "Project" (Implementation of part is explained in Section 5.3.2).
After tagging the email, the user wishes to view the list of emails with these tags, hence the user inputs `email list -tag Fun -tag Project`.

*Step 2* : `UI` component captures the input and passes to `Logic` component to parse the input.
Section below explains how `Logic` component parse the input.

* `CommandParseHelper` takes in the `input`, parses and extracts tags information and stores it inside ArrayList<Option>  `optionList`, then passes the `input` and `optionList` to `EmailCommandParseHelper`.
** `input` here is `email list`
** `optionList` here is `[tag=Fun, tag=Project]`
* `EmailCommandParseHelper` parses the `input` and extract tags information `optionList` and stores it in ArrayList<String> `tags`.
** `tags` here is `[Fun, Project]`
* `EmailCommandParseHelper` creates a new `EmailTagListCommand` by passing in `tags`, then return the `EmailTagListCommand` to `CommandParseHelper` and then to `UI`

*Step 3* : `EmailFilterByTagCommand#execute(model)` is called by `UI`.

*Step 4*: `EmailFilterByTagCommand` calls `EmailTags#filterByEmailTag(tags, emailList)`, which calls
`EmailTags#getTaggedEmailList(tags, emailList)`.


*Step 5*: `getTaggedEmailList()` checks the conditions of the each tags in `tags`, we say that a tag exists
if there
is email with the tag. If none of the emails has the tag, we say that the tag does not exist. We say that
both tags co-exist if there is email tagged with both tags.

** In this example, both tags `Fun` and `Project` co-exist.

*Step 6*: `getTaggedEmailList()` calls `TagMap.get("Fun").get("Project")`. `TagMap` returns `indexList`
which is the *index* of all email(s) tagged with both `Fun` and `Project`.

*Step 7*: `getTaggedEmailList()` constructs a String `responseMsg` containing the list of title of emails
from the `indexList`. After that, `getTaggedEmailList()` returns the `responseMsg` to `filterByEmailTag`, then
to `EmailFilterByTagCommand` and to the `UI`.

** `responseMsg` here is: +
"Here is the email tagged with both #Project and #Fun: <list of title of email(s) with both tags>"

===== Design Considerations

* Alternative 1 (current choice): +
The tags associated with emails is stored in `TagMap`. `TagMap` is updated upon every user input which will
invokes the `EmailTags#updateTagMap`.

** TagMap is a `HashMap<String, SubTagMap>`:
*** Each `key` in the HashMap is a tag name (we call it `root tag name` here) that exists in the email list.
*** The `value` associated with each `key` is a `SubTagMap`.

** `SubTagMap` is a `HashMap<String, IndexList>`:
*** Each `key` in the HashMap is a tag name (we call it `sub tag name` here) that co-exists with the `root tag
name` from the `TagMap`.
We say that both tags co-exist if there is email tagged with both tags.
*** The `value` associated with each `key` is an `IndexList`, which is an ArrayList<Integer> that stores the
index of emails tagged with both `root tag name` and `sub tag name`.

** For example, let `emailOne` be an email tagged with `Tutorial` and `CS2113T`, `emailTwo` be an email tagged with `Tutorial` and `CG2271`.
*** `emailOne` has index 1 nad `emailTwo` has index 2 in the email list.
*** After calling `EmailTags#updateTagMap`, the TagMap has the following structure: +
{ +
    Tutorial={Tutorial=[1, 2], CS2113T=[1], CG2271=[2]}, +
    CS2113T={CS2113T=[1], Tutorial=[1]}, +
    CG2271={CG2271=[2], Tutorial= [2]} +
}

** Pros: Faster search when user invokes `EmailFilterByTagCommand`, since `EmailTags#filterByEmailTag` is navigating in the HashMap.
** Cons: Current implementation invokes the `EmailTags#updateTagMap` on every user input to keep the tagMap and email list view in GUI updated, which increases the computational load.

* Alternative 2: +
Loop through each tag of each email in the list of emails, and check if the each tag equals to the tag requested by the user, if yes, add the email to the list, if no, continue with the loop.
After finishing the loop, output the email(s) in the list.

** Pros: This implementation does not have to maintain a `TagMap` structure to keep track of the emails
with the tags, therefore does not requires update of the `TagMap`, this saves the space and computational load of the program.
** Cons: Slower search when user invokes `EmailFilterByTagCommand`, since it has to loop through each tag of each email in the list of emails.

=== Logging

We are using¬†`java.util.logging`¬†package for logging.
The¬†`LogsCenter`¬†class is used to manage the logging levels and logging destinations.

===== Current Implementation

* The logging level can be controlled using the¬†logLevel
* The¬†Logger¬†for a class can be obtained using¬†LogsCenter.getLogger(Class)¬†which will log messages according to the specified logging level
* Currently log messages are output through:¬†Console¬†and to a¬†.log¬†file in `data/logs` folder with the format
`"log" + "yyyyMMdd_HHmm" + ".log"`.
* Logging Levels
** SEVERE¬†: Critical problem detected which may possibly cause the termination of the application
** WARNING¬†: Can continue, but with caution
** INFO¬†: Information showing the noteworthy actions by the App
** FINE¬†: Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

== Documentation

== Testing

== Dev Ops

=== Build Automation

We use https://gradle.org/[Gradle] for _build automation.
See link:{repoURL}/tutorials/gradleTutorial.md[Gradle Tutorial] for more details.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] to perform _Continuous Integration_ on our projects.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects.

=== Making a Release

Here are the steps to create a new release.

. Update the archiveVersion number of shadowJar in link:{repoURL}/build.gradle[`build.gradle`].
. Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
. Tag the repo with the version number. e.g. `v0.1`
. https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries.
For example, *Email manager* depends on the https://openjfx.io/[JavaFX] for GUI support.
Managing these _dependencies_ can be automated using Gradle.
For example, Gradle can download the dependencies automatically, which is better than these alternatives:

[loweralpha]
. Include those libraries in the repo (this bloats the repo size)
. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Suggested Programming Tasks to Get Started

[appendix]
== Product Scope

*Target user profile*:

. National University of Singapore (NUS) School of Computing Students.
. Busy computing student who is tired of receiving too many emails.
. Busy computing student who has a lot of todos, deadlines and events.
. Students who prefer desktop apps over other types.
. Students who prefer typing over other means of input.

*Value proposition*:

. Helps busy computing student to manage their emails.
. Helps busy computing student to manage their tasks and schedules.
. Reminds busy computing students of their important emails and tasks.

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

|=======================================================================
| As a/an | I can | So that... | Priority

|active student|get emails filtered out on student-life activities|I can get the interesting event info
immediately|`* * *`
|advanced user|tag the emails|I can search for them efficiently|`* * *`
|busy student|sort my task list according to my preferences|I can view and keep track of the tasks more
easily|`* * *`
|busy student|prioritize my tasks by setting priority levels|I can work on more pressing task first|`* * *`
|busy student|assign emails with color codes according to priority|I can have a clear view of priorities|`* * *`
|computing student|filter out different types of emails by specifying the type we want to filter|I can access the type of emails we want easily|`* * *`
|computing student|sort email according to module code|I can easily access the information related to my project|`* * *`
|computing student|set auto delete function to delete emails from a specific address|I can keep my mailbox clean|`* * *`
|computing student|filter out emails by specifying a keyword|I can access the email I am interested easily|`* * *`
|computing student|auto-categorize the emails|my mailbox is not messy|`* * *`
|email sender|send emails with tags|recipients can filter emails easily|`* * *`
|email user|get the list of unread emails|I can attend the unread easily|`* * *`
|job hunting student|add alarm to job/internship application deadlines|I will not miss any important application deadlines|`* * *`
|advanced user|advance search based on Regular expression|I can search with complex filters|`* *`
|advanced user|use shorter versions of command and auto-completion of command|I can type faster command|`* *`
|busy student|check my calendar to see if there are new added|I can keep track of my task efficiently|`* *`
|busy student|highlight tasks that are due soon (<24 hours)|I can work on things that are more pressing|`* *`
|busy student|set alarm to review some important emails|I can remember to attend to some important emails that I don't have time to handle now|`* *`
|busy student|sync with NUSMODS to automatically set deadlines for homework|I can my deadlines or homework assigned to a specific time|`* *`
|busy student|undo my previous command|recover to the previous state|`* *`
|computing student|set important emails to reply by a specific date|I won't miss any important deadlines|`* *`
|computing student|update my calendar if the email contains a date|I won't miss out important deadline|`* *`
|computing student|download all uploaded files sent through emails|I can get the latest version of the file|`* *`
|computing student|get connected with list on contacts on email|I can easily send to or find the email user|`* *`
|computing student|filter out competition/hackathon emails|I won't miss any interesting competition|`* *`
|computing student|find teams for competition/hackathon|I can quickly find teams after the competition email is sent out|`* *`
|email user|send, forward or reply to email|I do not need to switch to email app after reading from this app|`* *`
|email user|highlights links, action items|I can take action and quickly get to a website|`* *`
|email user|automatically restore emails that were thrown to the junk mail by the system|I won't miss any important emails just because they are in the junk mail without me knowing it|`* *`
|job hunting student|put away all outdated emails on internships/jobs|I can focus on the newest and valid ones|`* *`
|job hunting student|get the jobs and internship emails sorted|I can find a job|`* *`
|team member|tag emails with project stages|I can access emails from different stages of our project|`* *`
|team member|sort all emails from my team members together|I can easily access the information related to my project|`* *`
|team member|send progress tracking emails to other team members periodically|The team can be always updating each other's progress|`* *`
|=======================================================================

[appendix]
== Use Cases

*System*: `Email Manager`

*Actor*: `User` (SoC student)

[discrete]
=== Use Case: Snooze task

*MSS*

. User enters `snooze` command to snooze a task.
. Task is snoozed by default 3 days.
+
Use case ends.

*Extensions*

* 1a. User wants to snooze task by a specific duration.
+
** 1a1. User enters snooze duration after `snooze` command.
** 1a2. Task snoozed by the specific duration.
+
Use case ends.

* 1b. User snooze a task with invalid index.
+
** 1b1. Displays index out of bound message
+
Use case ends.

* 1c. User snooze a invalid task.
+
** 1c1. Displays task cannot be snoozed message
+
Use case ends.

[discrete]
=== Use Case: Sort task list

*MSS*

. User keys in `sort` command to sort task list by `sortType`.
. Task list is sorted according to `sortType`.
+
Use case ends.

*Extensions*

* 1a. Invalid `sortType` keyed after `sort` command.
** 1a1. Displays invalid sort type message
+
Use case ends.

[discrete]
=== Use Case: Add priority to task

*MSS*

. User keys in add priority command.
. Priority is added to the task.
+
Use case ends.

*Extensions*

* 1a. User keys in add priority command to the same task as above.
** 1a1. Priority of task is overwritten by new priority.
+
Use case ends.

[discrete]
=== Use Case: Clear task list

*MSS*

. User keys in `clear` command.
. Task list is cleared.
+
Use case ends.

*Extensions*

* 1a. User keys in `clear` command when task list is empty.
** 1a1. Displays message saying that task list has already been cleared.
+
Use case ends.

[discrete]
=== Use Case: Fetch email from account

*MSS*

. User starts system or enters the fetch command.
. System retrieves account key from file, connects to Microsoft and logs in. New emails are retrieved,
combined with those from local storage and displayed.
+
Use case ends.

*Extensions*

* 2a.
System is unable to retrieve a valid account key, receives error from Microsoft.
+
** 2a1. Opens Microsoft portal in browser. +
** 2a2. The user types in the username and password into Microsoft portal. +
** 2a3. System saves the account key from Microsoft for future logins, downloads new emails, and displays email.
+
Use case ends.

* 2b.
System does not receive a response from Microsoft server.
+
** 2b1. System notifies user of failure to log in and loads email from local file.
+
Use case ends.

[discrete]
=== Use Case: Set priority to different keyword

*MSS*

. The user selects the ‚ÄúKeyword Priority‚Äù from the menu
. System presents the user with all current priority settings
. The user selects ‚ÄúNew‚Äù from the menu
. System displays a text box for input of keyword/regular expression.
. The user types in the keyword/regular expression, selects the priority level of this keyword and selects ‚ÄúSave‚Äù and confirm
+
Use case ends.

[discrete]
=== Use Case: View Email List with Priority

*MSS*

. The user selects ‚ÄúAll Email‚Äù from the menu
. The user selects ‚Äúby Priority‚Äù from the menu
. System displays all the priorities and keywords under each priority
. The user selects the priority range that he/she wants to view
. System leads the user back to the email list page
+
Use case ends.

*Extensions*
* 3a.
The user can include or exclude a particular keyword from that priority
+
Use case ends.

[discrete]
=== Use Case: Auto categorisation of emails

*MSS*

. User creates a new categorize name.
. User specifies the keyword for this category.
. The app will look through the emails and put the related-emails under the category.
+
Use case ends.

[appendix]
== Non-Functional Requirements

Email Manager meets the following non-functional requirements:

* Security of user login credentials (user enters details directly into Microsoft portal)
* Data Accessibility (efficient storage)
// ^ should we take this out?
* Time-out
// ^ take this out as well?
* Clean layout
* Works with common operating systems

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS::
* Windows
* macOS
* Linux

//[appendix]
//== Product Survey
//
[appendix]
== Instructions for Manual Testing
Please follow the following feature testing tables to do the manual testing. The actual output and error
message are to be checked against the expected output in the table. If Internet access is not available,
please copy the content in the `/data/test_data` folder to the `/data` folder and overwrite all. These two
folders
will be automatically generated once the program is started. +
Please ensure the program is copied to an empty folder before starting the testing to avoid any data
contamination. Any manual changes to the data folder might affect the program from function normally and is
not recommended.

[NOTE]
As we are using key mapping for certain hotkeys, you will not be able to use `Ctrl + V` for pasting.
However, you can right click on the input box and choose paste to paste the test input.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more
exploratory testing.


=== Feature Testing

==== Natural dates support

|===
|‚ÑπÔ∏è|All dates in natural dates format are case-insensitive
|===

|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`deadline submission -time mon`|deadline task will be added into the task list with time `0000`|Normal
use case without time inputted
|`Task`|`deadline submission -time mon 2359`|deadline task will be added into the task list with time
`2359`|Normal use case with time inputted
|`Task`|`deadline submission -time`|Invalid command format reported|Empty time in time option triggers
invalid command format as deadline task requires a time option
|`Task`|`deadline submission -time abc`|Invalid command reported asking for correct date time format|Invalid
input with wrong date time format
|`Task`|`todo tutorials -time`|Invalid command format reported|Invalid input with time present in todo task
|`Task`|`todo tutorial -time mon 1200`|Invalid command reported saying date time not allowed for todo
task|Invalid input with time present in todo task
|===

==== Sort task list Command

|===
|‚ÑπÔ∏è|Inputs after `sort` are case-insensitive.
|===

|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`sort priority`|Task List is sorted according to the priority level of the task, with `high` being at
the top of the list|Normal use case
|`Task`|`sort`|Invalid command reported asking for sort type after `sort`|Invalid input without sort type
|`Task`|`sort prio`|Invalid command reported saying invalid sorting type|Invalid input with invalid sort type
|===

==== Snooze task Command

|===
|‚ÑπÔ∏è|Snooze can only work for `deadline` and `event` tasks.
|===

To aid with testing, let task with index 1 be a `deadline` task, and task with index 2 be a `todo` task.

|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`snooze 1`|Task with index 1 is snoozed by 3 days|Normal use case without a specific duration to snooze
|`Task`|`snooze 1 -by 2`|Task with index 1 is snoozed by 2 days|Normal use case with a specific duration to snooze
|`Task`|`snooze`|Invalid command reported asking for valid task index and duration|Invalid input without task
index
|`Task`|`snooze 0`|Invalid command reported saying index out of bound|Invalid input with invalid index
|`Task`|`snooze abc`|Invalid command reported asking for valid task index and duration|Invalid input with
invalid index
|`Task`|`snooze 123456`|Invalid command reported saying invalid index|Invalid input with index that is out of
range of 1 ~ 99999
|`Task`|`snooze 1 -by 123456`|Message displayed asking for snooze duration to be within range of 1 ~
99999|Invalid input with snooze duration that is too large
|`Task`|`snooze 2`|Message displayed saying task cannot be snoozed|Invalid input of invalid task type
|`Task`|`snooze 2 -by abc`|Invalid command reported asking for valid snooze duration|Invalid input with
invalid task index and invalid snooze duration
|===

==== Set Priority Command

|===
|‚ÑπÔ∏è|Priority levels keyed in after `-priority` are case-insensitive
|===

|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`set 1 -priority high`|Priority of task 1 set to `HIGH`|Normal use case
|`Task`|`set 1`|Invalid command reported asking for valid priority level to be set|Invalid input with
missing priority level
|`Task`|`set 1 -priority`|Invalid command format reported|Invalid input without priority level
|`Task`|`set 1 -priority abc`|Invalid priority reported|Invalid input with invalid priority level
|`Task`|`set 0 -priority high`|Invalid command reported saying index out of bound|Invalid input with
invalid index
|`Task`|`set abc -priority high`|Invalid command reported asking for positive index that is in range and
priority level|Invalid input with invalid index
|`Task`|`set`|Invalid command reported asking for positive index that is in range and
priority level|Invalid input without index
|===

==== Doafter Command

|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`doafter 1 -msg do something`|Task 1 has `do something` set as a task to be done after|Normal use case
|`Task`|`doafter`|Invalid command reported asking for positive index that is in valid and description|Invalid input without
|`Task`|`doafter abc`|Invalid command reported asking for valid positive index with description|Invalid input with non-positive integer index
|`Task`|`doafter 0`|Invalid command reported saying index out of bound|Invalid input with invalid index
|`Task`|`doafter 1`|Invalid command reported asking for description|Invalid input with missing doafter message
|`Task`|`doafter 1 -msg`|Invalid command format reported asking for description|Invalid input without description

|===

==== Update Command
|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`update 1 -priority high`|Priority of task 1 set to `HIGH`|Normal use case
|`Task`|`update 3 -time 19/02/2019 1200 -doafter CS2113T -tag a -tag b`|Task 1 time, doafter and tags are updated as per input|Normal use case, multiple parameters
|`Task`|`update`|Invalid command reported asking for valid index|Invalid input with
missing index
|`Task`|`update 1`|Invalid command format reported asking for at least one valid parameter to change|Invalid input without items to change
|`Task`|`update abc`|Invalid command format asking for valid index reported|Invalid input with non-integer index
|`Task`|`update 0 -priority low`|Invalid command reported saying index out of bound|Invalid input with non-positive integer
|`Task`|`update 1 -priority high -priority low`|Invalid command reported, too many of the same parameter (only 1 allowed for priority, time and doafter)|Invalid input with too many parameters
|`Task`|`update 1 -priority abc`|Invalid command reported asking for at least one valid parameter|Invalid input, wrong parameter format (for priority and time)
|===

==== Link Command
|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`link 1`|Displays a list of emails linked to task 1|Normal use case
|`Task`|`link 1 -email 1`|Links email 1 to task 1, and displays links|Normal use case, addition of links
|`Task`|`link 1 -delete 1`|Deletes link 1 for task 1, if it exists. Displays updated list of links|Normal use case, deletion of links
|`Task`|`link 1 -email 3 -delete 1 -email 9`|Deletes link 1 (if it exists), then links email 3 and 9. Displays updated list of links|Normal use case, mixture of parameters
|`Task`|`link`|Invalid command format asking for valid index reported|Invalid input with no index
|`Task`|`link abc`|Invalid command reported asking for a valid index reported|Invalid input with non-integer index
|`Task`|`link 0`|Invalid command reported saying index out of bound|Invalid input with non-positive integer
|`Task`|`link 1 -delete`|Invalid command, wrong format for parameter|Parameter does not have valid index

|===

==== Clear task list Command

|===
|Mode|Input|Expected Result|Purpose of Testing

|`Task`|`clear`|Task list is cleared|Normal use case
|`Task`|`clear`|Message saying task list has already been cleared|Using the command consecutively
|===

==== Email Auto Parsing and AddKeyword Command
Since the email content parsing is automatic, it is easier to be tested together with the addKeyword command.

[NOTE]
All the expression match is case insensitive and full match, meaning that 'cs' can be matched to 'CS' but
not 'CS2101'.

|===
| Mode | Input | Expected Result | Purpose of Testing

| `email` | `addKeyword Notice -exp announcement` | All emails with the word 'announcement' in its subject,
sender or body will have #Notice on the list | Normal use case of addKeyword and auto parsing
| `email` | `addKeyword Project -exp project -exp demo` | All emails with the word 'project' or 'demo'
in its subject, sender or body will have #Project on the list | Normal use case with multiple
expressions in one keyword
| `email` | `addKeyword Project Demo -exp project -exp demo` | All emails with the word 'project' or 'demo'
in its subject, sender or body will have #Project Demo on the list | Normal use case with space in keyword
| `email` | `addKeyword Demo -exp final demo` | All emails with the word 'final demo'
in its subject, sender or body will have #Demo on the list | Normal use case with space in expression
| `email` | `addKeyword Project Demo -exp luminus` | All emails with the word 'luminus' in its subject,
sender, or body will have #Project Demo on the list. Those emails already have #Project Demo will not be
affected | Normal use case with new expression but existing keyword
| `email` | `addKeyword 46 -exp 46` | All emails with '46' in its subject, sender or body will have #46 on
the list | Normal use case with numbers in keyword and expression

| `email` | `addKeyword` | Invalid command reported asking for a keyword after `addKeyword` | Invalid input
without keyword specified
| `email` | `addKeyword -exp project` | Invalid command reported asking for a keyword after `addKeyword` |
Invalid input with expression but without keyword specified
| `email` | `addKeyword project` | Invalid command reported asking for expression options | Invalid input
without expression specified
| `email` | `addKeyword project -exp` | Invalid command format reported | Empty expression in expression
option should trigger the invalid command format check as option must not be empty
| `email` | `addKeyword project -exp !@#` | Invalid command format reported | Invalid character in input
will trigger the invalid command format check
|===

==== Email Fuzzy Search

[NOTE]
For performance reasons, fuzzy search will only be done word by word. For example, if "project demo" is to
be searched through a sentence "This is a project demo", both "project" and "demo" will be compared against
"this", "is", "a", "project", "demo" and produce a relevance score.

[NOTE]
Using short target string like "is" is not recommended, since it can be matched to many other words like
"a", "I", "am" etc, which appears in almost every email.

|===
| Mode | Input | Expected Result | Purpose of Testing

| `email` | `fuzzySearch Aggarwal` | A few emails sent by Divesh Aggarwal will be listed | Normal use case
with exact match should be captured by fuzzy search
| `email` | `fuzzySearch Aggarwa` | A few emails sent by Divesh Aggarwal will be listed | Normal use case
with edit distance of 1 should be captured by fuzzy search
| `email` | `fuzzySearch Aggarw` | A few emails sent by Divesh Aggarwal will be listed | Normal use case
with edit distance of 2 should be captured by fuzzy search
| `email` | `fuzzySearch Aggar` | No email will be listed | Normal use case with edit distance of 3 will
not be captured by fuzzy search
| `email` | `fuzzySearch Divesh Aggarwal` | A few emails sent by Divesh Aggarwal will be listed | Normal
use case with more than two target words should be captured properly
| `email` | `fuzzySearch CS2113` | Many emails about CS2113T, CS2101, CS2102 should be listed, with CS2113T
emails generally listed first | Normal use case when multiple words can be matched but the most relevant
should be listed first
|===

==== Email Tagging
*Duke Email Manager* allows user to tag emails by tags.

[NOTE]
Minimum number of tags is 1. Tags without duplication will be added.

|===
| Mode | Input | Expected Result | Purpose of Testing

| `email` | `update 1 -tag project` | The 1st email will have #project on the list | Normal use case of
tagging email
| `email` | `update 1 -tag final demo` | The 1st email will have #project demo on the list | Normal use
case with space in tag
| `email` | `update 1 -tag notice -tag fun` | The 1st email will have #notice and #fun on the list | Normal
use case with multiple tags
| `email` | `update 1 -tag notice` | The 1st email will have #notice remains on the list | Normal use case
with existing tag
| `email` | `update 1 -tag notice -tag career` | The 1st email will have new tag #career on the list, the
tag #notice remains on the list | Normal use case with multiple tags including existing and new tags
| `email` | `update 1 -tag 123` | The 1st email will have #tag on the list| Normal use case with numbers in tag

| `email` | `update` | Invalid command reported asking for an index after `update`| Invalid input
without index specified
| `email` | `update -tag 123` | Invalid command reported asking for an index after `update`| Invalid input
with tag but without index specified
| `email` | `update 1` | Invalid command reported asking for tag options| Invalid input without tag specified
| `email` | `update 1 -tag` | Invalid command format reported | Empty tag in tag option should trigger the
 invalid command format check as option must not be empty
| `email` | `update 1 -tag!@#` | Invalid command format reported | Invalid character in input will
trigger the invalid command format check


|===

=== Launch and Shutdown
. Initial launch
... Download the jar file and copy into an empty folder
... Double-click the jar file +
Expected: Shows the GUI with a set of sample tasks and emails. The window size may not be optimum.
. Exiting the program
... Type exit into the user input box.
... Expected: Application will shut down and close itself.